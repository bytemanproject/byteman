##############################################################################
# JBoss, Home of Professional Open Source
# Copyright 2008, Red Hat Middleware LLC, and individual contributors
# by the @authors tag. See the copyright.txt in the distribution for a
# full listing of individual contributors.
#
# This is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation; either version 2.1 of
# the License, or (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this software; if not, write to the Free
# Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301 USA, or see the FSF site: http://www.fsf.org.
#
# @authors Andrew Dinn
#
# Heuristic Recovery After Delayed Commit in Single JVM
#
# This script automates testing of a specific recovery scenario for the
# JBossTS XTS implementation of the WS-AT 1.0 protocol using orchestration
# rules. The scenario is as follows:
#
# AS boots
# Client starts a WS-AT transaction
# Client invokes web service 1
# Web service 1 registers as participant P1
# Client invokes web service 2
# Web service 2 registers as participant P2
# Client commits WS-AT transaction
# Coordinator initiates commit of participant P1
# ** Rule system intercepts commit and crahses JVM
#
# AS reboots
# Recovery system starts after 2 minutes
# Recovery system recreates PREPARED WS-AT transaction coordinator
# Recovery system recreates participant stub for P1
# ** Rule system adds countdown(2) for P1
# Recovery system recreates participant stub for P2
# ** Rule system adds countdown for P2
# Recovery system calls replay of PREPARED transaction
# ** Rule system traces PREPARED replay invocation
# Coordinator sends commit to P1
# ** Rule system decrements P1's countdown to 1
#
# P1 replies with committed
# ** Rule system intercepts committed message handler and aborts thread
#
# Coordinator sends commit to P2
# ** Rule system decrements P2's countdown to 1
# (last 2 steps repeated while countdown is active)
#
# P2 replies with committed
# ** Rule system intercepts committed message handler and aborts thread
# (last 2 steps repeated while countdown is active)
#
# Coordinator times out commit and writes heuristic transaction to log
# Recovery system sleeps

# Recovery system restarts after 2 minutes
# Recovery system recreates HEURISTIC WS-AT transaction coordinator
# Recovery system detects existing participant stub for P1
# Recovery system detects existing participant stub for P2
#
# Coordinator sends commit to P1
# ** Rule system decrements P1's countdown to 0 and removes countdown
# P1 replies with committed
# Coordinator sends commit to P2
# ** Rule system decrements P2's countdown to 0 and removes countdown
# P2 replies with committed
# Coordinator clears heuristic log record and copletes commit
# ** Rule system detects completed commit and kills JVM
#
# The number of participants must be at least 2 but can actually be
# more. One way of exercising the test is to start the AS and run the
# XTS demo. It should crash at the point of commit. At reboot the
# rest of the test shoudl run automatically and the server should be
# killed after a the heuristic transaction is successfuly killed. The
# console (or server) log should contain messages indicating replays of
# the prepared and then the heuristic transactions and then a message
# indicating that the heuristic transacton has committed.

#######################################################################
# This rule is triggered when a participant stub (CoordinatorEngine) is
# created from details located in the log record. It adds a countdown
# which is tripped each time a commit is tried on the participant.
# While the countdown is active committed messages will be blocked.
# Note that it calls isRecovered() to detect that the stub has been
# recreated from the log.
# The line number is the line following the assignments of the local state.
# This ensures the rule is triggered after invocation of
# the super class constructor. Placing the trigger after the super
# constructor call is vital for constructors since the rule cannot call
# methods on the instance until after it has been initialized. In theory
# it should be possible to set line = -1 and have the rule system compile
# in the trigger call at the correct place. However, it is not smart enough
# to do this just yet

RULE add coordinator engine countdown
CLASS com.arjuna.wst.messaging.engines.CoordinatorEngine
METHOD <init>(String, boolean, EndpointReferenceType, boolean, State)
LINE 118
BIND engine:CoordinatorEngine = $0,
     recovered:boolean = engine.isRecovered(),
     identifier:String = engine.getId()
IF recovered
DO debug("adding countdown for " + identifier),
   addCountDown(identifier, 1)
ENDRULE

#######################################################################
# This rule is triggered when a non-recovered participant stub
# (CoordinatorEngine) is sent a commit message i.e. immediately
# after a successful prepare. It exits the JVM, simulating a crash.
# The line number is the first executable line in the method (it
# could be specified as -1)

RULE kill JVM
CLASS com.arjuna.wst.messaging.engines.CoordinatorEngine
METHOD commit
LINE 369
BIND engine:CoordinatorEngine = $0,
     recovered:boolean = engine.isRecovered(), 
     identifier:String = engine.getId()
IF (NOT recovered)
   AND
   debug("commit on non-recovered engine " + identifier)
DO debug("!!!killing JVM!!!"),
   killJVM()
ENDRULE

#######################################################################
# This rule is triggered when a recovered participant stub
# (CoordinatorEngine) is sent a commit message i.e. immediately
# after a successful prepare. It decrements the countdown. First
# time round this takes it from 1 to 0 but leaves it in place. Second
# time round it removes it allowing committed messages to flow.
# The line number is the first executable line in the method (it
# could be specified as -1)

RULE countdown at commit
CLASS com.arjuna.wst.messaging.engines.CoordinatorEngine
METHOD commit
LINE 369
BIND engine:CoordinatorEngine = $0,
     recovered:boolean = engine.isRecovered(),
     identifier:String = engine.getId()
IF recovered
   AND
   debug("commit on recovered engine " + identifier)
   AND
   debug("counting down")
   AND
   countDown(identifier)
DO debug("countdown completed for " + identifier)
ENDRULE

#######################################################################
# This rule is triggered when a recovered participant stub
# (CoordinatorEngine) is sent a committed message i.e. in the handler
# thread which responds to a COMMITTED message from a participant.
# If it detects a countdown registered using the participant id it
# throws a runtime exception causing the thread to abort and stopping
# delivery of the COMMITTED message. The line number is -1 so the
# rule code gets run as soon as the method is entered.

RULE kill committed thread
CLASS com.arjuna.wst.messaging.engines.CoordinatorEngine
METHOD committed(NotificationType, AddressingContext, ArjunaContext)
LINE -1
BIND engine:CoordinatorEngine = $0,
     recovered:boolean = engine.isRecovered(),
     identifier:String = engine.getId()
IF recovered
   AND
   debug("committed on recovered engine " + identifier)
   AND
   getCountDown(identifier)
DO debug("!!!killing committed thread for " + identifier + "!!!"),
   return
ENDRULE

#######################################################################
# This rule is triggered when the recovery system finds the PREPARED
# transaction in the log and reruns the phase 2 commit operation.
# It prints a message which can be used to verify that the test has
# worked correctly. The line number is the one where the call to
# phase2Commit is called but actually the test would also work with
# line = -1 since the condition selects the correct case.

RULE trace prepared replay
CLASS org.jboss.jbossts.xts.recovery.RecoverACCoordinator
METHOD replayPhase2
LINE 74
BIND coordinator = $0,
     uid : Uid = coordinator.identifier(),
     status : int = coordinator.status()
IF (status == com.arjuna.ats.arjuna.coordinator.ActionStatus.PREPARED)
     OR
     (status == com.arjuna.ats.arjuna.coordinator.ActionStatus.COMMITTING)
DO debug("replaying commit for prepared transaction " + uid)
ENDRULE

#######################################################################
# This rule is triggered when the recovery system finds the COMMITTED
# transaction in the log and reruns the phase 2 commit operation.
# It prints a message which can be used to verify that the test has
# worked correctly. The line number is the one where the call to
# phase2Commit is called but actually the test would also work with
# line = -1 since the condition selects the correct case.

RULE trace heuristic committed replay
CLASS org.jboss.jbossts.xts.recovery.RecoverACCoordinator
METHOD replayPhase2
LINE 74
BIND coordinator = $0,
     uid : Uid = coordinator.identifier(),
     status : int = coordinator.status()
IF status == com.arjuna.ats.arjuna.coordinator.ActionStatus.COMMITTED
DO debug("replaying commit for heuristic committed transaction " + uid)
ENDRULE

#######################################################################
# This rule is triggered when the recovery system deletes the COMMITTED
# transaction from the log. It prints a message which can be used to
# verify that the test has worked correctly. It also kills the JVM to
# halt the test. The line number is the one just following the delete
# of the record from the TX object store, ensuring that the JVM is not
# exited until the log has actually been cleaned up.

RULE trace remove committed state
CLASS com.arjuna.ats.arjuna.coordinator.BasicAction
METHOD updateState
LINE 3529
BIND action : BasicAction = $0,
     uid  = action.get_uid()
IF TRUE
DO debug("removed committed transaction " + uid),
   debug("!!!killing JVM!!!"),
   killJVM()
ENDRULE
